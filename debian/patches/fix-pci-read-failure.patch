Description: Only read capability registers if the capability exists
 From https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=4c009af473b2026caaa26107e34d7cc68dad7756:
 During driver init, various registers are saved to allow restoration
 after an FLR or gen3 bump. Some of these registers are not available
 in some circumstances (i.e. Virtual machines).
 .
 This bug makes the driver unusable when the PCI device is passed into
 a VM, it fails during probe.
 .
 Delete unnecessary register read/write, and only access register if
 the capability exists.
 .
 Cc: <stable@vger.kernel.org> # 4.14.x
 Fixes: a618b7e40af2 ("IB/hfi1: Move saving PCI values to a separate function")
 Reviewed-by: Mike Marciniszyn <mike.marciniszyn@intel.com>
 Signed-off-by: Michael J. Ruhl <michael.j.ruhl@intel.com>
 Signed-off-by: Dennis Dalessandro <dennis.dalessandro@intel.com>
 Signed-off-by: Jason Gunthorpe <jgg@mellanox.com>
Author: Brian T. Smith <bsmith@systemfabricworks.com>
Forwarded: not-needed
Last-Update: <2018-04-06>
---
This patch header follows DEP-3: http://dep.debian.net/deps/dep3/
--- a/hfi1/hfi.h
+++ b/hfi1/hfi.h
@@ -1008,7 +1008,6 @@
 	u16 pcie_lnkctl;
 	u16 pcie_devctl2;
 	u32 pci_msix0;
-	u32 pci_lnkctl3;
 	u32 pci_tph2;
 
 	/*
--- a/hfi1/pcie.c
+++ b/hfi1/pcie.c
@@ -489,14 +489,11 @@
 	if (ret)
 		goto error;
 
-	ret = pci_write_config_dword(dd->pcidev, PCIE_CFG_SPCIE1,
-				     dd->pci_lnkctl3);
-	if (ret)
-		goto error;
-
-	ret = pci_write_config_dword(dd->pcidev, PCIE_CFG_TPH2, dd->pci_tph2);
-	if (ret)
-		goto error;
+	if (pci_find_ext_capability(dd->pcidev, PCI_EXT_CAP_ID_TPH)) {
+		ret = pci_write_config_dword(dd->pcidev, PCIE_CFG_TPH2, dd->pci_tph2);
+		if (ret)
+			goto error;
+	}
 
 	return 0;
 
@@ -547,14 +544,11 @@
 	if (ret)
 		goto error;
 
-	ret = pci_read_config_dword(dd->pcidev, PCIE_CFG_SPCIE1,
-				    &dd->pci_lnkctl3);
-	if (ret)
-		goto error;
-
-	ret = pci_read_config_dword(dd->pcidev, PCIE_CFG_TPH2, &dd->pci_tph2);
-	if (ret)
-		goto error;
+	if (pci_find_ext_capability(dd->pcidev, PCI_EXT_CAP_ID_TPH)) {
+		ret = pci_read_config_dword(dd->pcidev, PCIE_CFG_TPH2, &dd->pci_tph2);
+		if (ret)
+			goto error;
+	}
 
 	return 0;
 
